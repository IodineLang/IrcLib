use ssl;
use socket;
use EventEmitter from events;

class IRCClient : EventEmitter {
    
    func IRCClient (self) {
        self.sock = socket.socket (socket.SOCK_STREAM, socket.PROTO_TCP);
        self.nick = "IRCClient";
        self.hostname = "IRCClient";
        self.servername = "IRCClient";
        self.realname = "IRCClient";
    }

    func parseMessage (self, message) {
        prefix = "";
        command = "";
        params = "";
        if (message.startsWith (":")) {
            prefix = message.substr (1, message.indexOf (" "));
            command = message.substr (message.indexOf (" ") + 1);   
        } else {
            command = message;
        }

        params = self.parseParams (command.substr (command.indexOf (" ")))
            when command.contains (" ") else [];
    
        command = command.substr (0, command.indexOf (" "))
            when command.contains ("") else command;

        return (prefix, command, params);
    }

    func parseParams (self, rawParams) {
        paramList = [];
        params = rawParams.substr (0, rawParams.indexOf (":"))
            when rawParams.contains (":") else rawParams;
        params = params.trim ();
        
        if (len (params) > 0) {
            paramList.addRange (params.split (" "));
        }
        if (rawParams.contains (":")) {
            
            paramList.add (rawParams.substr (rawParams.indexOf (":") + 1));
        }
        
        return paramList;
    }

    func parsePrefix (self, message) {
        name = message.substr (0, message.indexOf ("!"))
            when message.contains ("!") else name;
        return (name, "", "");   
    }

    func connect (self, ip, port, *args) {
        useSsl = false;
        if (len (args) > 0) {
            useSsl = args [0];
        }
        self.ipAddress = ip;
        self.port = port;
        self.sock.connect (self.ipAddress, self.port);
        self.stream = self.sock.getStream ();
        if (useSsl) {
            self.stream = ssl.wrapStream (self.stream);
        }
        self._connectionMade ();

        self.sendRaw ("USER {} {} {} :{}", self.nick, 
            self.hostname,
            self.servername,
            self.realname);
            
        self.sendRaw ("NICK {}", self.nick);
        
        while (true) {
            line = self.stream.readLine ().trim ();
            if (len (line) > 0) {
                self.handleMessage (line);
            }
        }
    }

    func handleMessage (self, rawMessage) {
        message = self.parseMessage (rawMessage);
        prefix = self.parsePrefix (message [0]);
        sender = prefix [0];
        cmd = message [1];
        params = message [2];
        given (cmd) {
            when "PING" {
                self.sendRaw ("PONG :{}", params [0]);
            }
            when "PRIVMSG" {
                self._privmsg (sender, params [0], params [1]);           
            }
            when "JOIN" {
                if (sender == self.nick) {
                    self._joined (params [0]);
                } else {
                    self._userJoined (sender, params [0]);
                }
            }
            when "PART" {
                if (sender == self.nick) {
                    self._parted (params [0]);
                } else {
                    self._userPart (sender, params [0]);
                }
            }
            when "QUIT" {
                if (sender == self.nick) {
                    self._quit (prefix [0]);
                } else {
                    self._userQuit (sender, prefix [0]);
                }
            }
            when "KICK" {

            }
        }
    } 

    
    func sendRaw (self, format, *args) {
        self.stream.write (format.format (*args) + "\r\n");
    }
    
    func say (self, channel, msg) {
        if (channel != self.nick) {
            self.sendRaw ("PRIVMSG {} :{}", channel, msg);
        }
    }

    func join (self, channel) {
        self.sendRaw ("JOIN {}", channel);
    }

    func part (self, channel) {
        self.sendRaw ("PART {}", channel);
    }
    
    func connectionMade (self) { }
    func privmsg (self, sender, channel, command) { }
    func joined (self, channel) { }
    func parted (self, channel, reason) { }
    func userJoined (self, user, channel) { }
    func userParted (self, user, channel, reason) { }
    func userQuit (self, user, reason) { }
    func kicked (self, kicker, channel, reason) { }
    func userKicked (self, kicker, kickee, channel, reason) { }
    
    func _connectionMade (self) {
        self.connectionMade ();
        self.emit ("connectionMade", self);
    }
    
    func _privmsg (self, sender, channel, command) {
        self.privmsg (sender, channel, command);
        self.emit ("privmsg", self, sender, channel, command);
    }
    
    func _joined (self, channel) {
        self.joined (channel);
        self.emit ("joined", self, channel);
    }
    
    func _parted (self, channel, reason) {
        self.parted (channel, reason);
        self.emit ("parted", self, channel, reason);
    }
    
    func _userJoined (self, user, channel) {
        self.userJoined (user, channel);
        self.emit ("userJoined", self, user, channel);
    }
    
    func _userParted (self, user, channel, reason) {
        self.userParted (user, channel, reason);
        self.emit ("userParted", self, user, channel);
    }
    
    func _userQuit (self, user, reason) {
        self.userQuit (user, reason);
        self.emit ("userQuit", self, user, reason);
    }
    
    func _kicked (self, kicker, channel, reason) {
        self.kicked (kicker, channel, reason);
        self.emit ("kicked", kicker, channel, reason);
    }
    
    func _userKicked (self, kicker, kickee, channel, reason) {
        self.userKicked (kicker, kickee, channel, reason);
        self.emit ("userKicked", self, kicker, kickee, channel, reason);
    }
}
